# ITensorMPOCompression

A package to enable block respecting compression of Matrix Product Operators (MPOs) to use with ITensors.jl.
  Reference: *Daniel E. Parker, Xiangyu Cao, and Michael P. Zaletel Phys. Rev. B 102, 035147*
  ITensors has built in support for generating MPOs from local operators. This framework is `AutoMPO`.  MPOs
  generated by `AutoMPO` are already compressed, so you only need this package
  if you are 
    1. using MPOs that are created by hand, outside the `AutoMPO` framework.  
    2. You want your MPO to be in orthogonal/canonical form.
    3. You need to see the bond spectrums throughout the lattice. 

  Support for compression of infinite lattice MPOs (iMPOs) is in the ITensorInfiniteMPS package
  which can be found here: [link](https://github.com/ITensor/ITensorInfiniteMPS.jl)



## Installation

You can install this package through the Julia package manager:
```julia
julia> ] add ITensorMPOCompression
```
## Examples

Here are is an example of orthogonalizing an hand generated (not using AutoMPO) MPO

```julia
julia> using ITensors

julia> using ITensorMPOCompression

julia> include("../test/hamiltonians/hamiltonians.jl")
Hubbard_AutoMPO (generic function with 1 method)

julia> N = 10; #10 sites

julia> NNN = 7; #Include up to 7th nearest neighbour interactions

julia> sites = siteinds("S=1/2", N);

julia> H = transIsing_MPO(sites, NNN);

julia> is_regular_form(H,lower) == true
true

julia> get_Dw(H) #Show bond dimensions
9-element Vector{Int64}:
 30
 30
 30
 30
 30
 30
 30
 30
 30

julia> pprint(H[2]) #schematic view of operators at site #2
I 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
S 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
S 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
0 0 I 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
S 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
0 0 0 0 I 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
0 0 0 0 0 I 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
S 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
0 0 0 0 0 0 0 I 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
0 0 0 0 0 0 0 0 I 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
0 0 0 0 0 0 0 0 0 I 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
S 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
0 0 0 0 0 0 0 0 0 0 0 I 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
0 0 0 0 0 0 0 0 0 0 0 0 I 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
0 0 0 0 0 0 0 0 0 0 0 0 0 I 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
0 0 0 0 0 0 0 0 0 0 0 0 0 0 I 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
S 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 I 0 0 0 0 0 0 0 0 0 0 0 0 0 
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 I 0 0 0 0 0 0 0 0 0 0 0 0 
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 I 0 0 0 0 0 0 0 0 0 0 0 
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 I 0 0 0 0 0 0 0 0 0 0 
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 I 0 0 0 0 0 0 0 0 0 
S 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 I 0 0 0 0 0 0 0 
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 I 0 0 0 0 0 0 
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 I 0 0 0 0 0 
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 I 0 0 0 0 
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 I 0 0 0 
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 I 0 0 
0 S 0 S 0 0 S 0 0 0 S 0 0 0 0 S 0 0 0 0 0 S 0 0 0 0 0 0 S I 


julia> orthogonalize!(H,1) #Orthogonalize and put the ortho center at site #1.  Also does rank reduction.
(0, 2)

julia> pprint(H[2]) #Show vastly reduced matrix of operators at site #2
I 0 0 0 0 0 0 0 0 
S 0 0 0 0 0 0 0 0 
0 I 0 0 0 0 0 0 0 
0 0 I 0 0 0 0 0 0 
0 0 0 I 0 0 0 0 0 
0 0 0 0 I 0 0 0 0 
0 0 0 0 0 I 0 0 0 
0 0 0 0 0 0 I 0 0 
0 S S S S S S S I 


julia> get_Dw(H) #Show reduced bond dimensions
9-element Vector{Int64}:
 9
 9
 9
 8
 7
 6
 5
 4
 3

julia> is_regular_form(H,lower) == true
true

julia> isortho(H, right) == true #looks at cached ortho center limits
true

julia> check_ortho(H,right) == true #Does the more expensive V*V_dagger==Id contraction and test
true

julia> pprint(H) #High level view of what is in the MPO.
  n    Dw1  Dw2   d   Reg.  Orth.
                      Form  Form 
   1    1    9    2    L      M
   2    9    9    2    L      R
   3    9    9    2    L      R
   4    9    8    2    L      R
   5    8    7    2    L      R
   6    7    6    2    L      R
   7    6    5    2    L      R
   8    5    4    2    L      R
   9    4    3    2    L      R
  10    3    1    2    L      B
```


Here are is an example of truncating an hand generated (not using AutoMPO) MPO

```julia
julia> using ITensors

julia> using ITensorMPOCompression

julia> include("../test/hamiltonians/hamiltonians.jl")
Hubbard_AutoMPO (generic function with 1 method)

julia> N = 10; #10 sites

julia> NNN = 7; #Include up to 7th nearest neighbour interactions

julia> sites = siteinds("S=1/2", N);

julia> H = transIsing_MPO(sites, NNN);

julia> is_regular_form(H,lower) == true
true

julia> spectrums = truncate!(H,left)
9-element Vector{Spectrum}:
 Spectrum{Vector{Float64}, Float64}([9.4e-02], 0.0e+00)
 Spectrum{Vector{Float64}, Float64}([1.3e-01, 1.2e-03], 0.0e+00)
 Spectrum{Vector{Float64}, Float64}([1.4e-01, 2.0e-03, 4.3e-04], 0.0e+00)
 Spectrum{Vector{Float64}, Float64}([1.5e-01, 2.0e-03, 6.9e-04, 3.1e-04], 0.0e+00)
 Spectrum{Vector{Float64}, Float64}([1.5e-01, 1.8e-03, 9.6e-04, 3.5e-04, 5.3e-07], 0.0e+00)
 Spectrum{Vector{Float64}, Float64}([1.5e-01, 2.0e-03, 6.9e-04, 3.1e-04], 0.0e+00)
 Spectrum{Vector{Float64}, Float64}([1.4e-01, 2.0e-03, 4.3e-04], 0.0e+00)
 Spectrum{Vector{Float64}, Float64}([1.3e-01, 1.2e-03], 0.0e+00)
 Spectrum{Vector{Float64}, Float64}([9.4e-02], 0.0e+00)

julia> pprint(H[5])
I 0 0 0 0 0 0 
S S S S S S 0 
S S S S S S 0 
S S S S S S 0 
S S S S S S 0 
0 S S S S S I 


julia> @show get_Dw(H)
get_Dw(H) = [3, 4, 5, 6, 7, 6, 5, 4, 3]
9-element Vector{Int64}:
 3
 4
 5
 6
 7
 6
 5
 4
 3

julia> @show spectrums
spectrums = 
Bond  Ns   max(s)     min(s)    Entropy  Tr. Error
   1    1  0.30739   3.07e-01   0.22292  0.00e+00
   2    2  0.35392   3.49e-02   0.26838  0.00e+00
   3    3  0.37473   2.06e-02   0.29133  0.00e+00
   4    4  0.38473   1.77e-02   0.30255  0.00e+00
   5    5  0.38773   7.25e-04   0.30588  0.00e+00
   6    4  0.38473   1.77e-02   0.30255  0.00e+00
   7    3  0.37473   2.06e-02   0.29133  0.00e+00
   8    2  0.35392   3.49e-02   0.26838  0.00e+00
   9    1  0.30739   3.07e-01   0.22292  0.00e+00

9-element Vector{Spectrum}:
 Spectrum{Vector{Float64}, Float64}([9.4e-02], 0.0e+00)
 Spectrum{Vector{Float64}, Float64}([1.3e-01, 1.2e-03], 0.0e+00)
 Spectrum{Vector{Float64}, Float64}([1.4e-01, 2.0e-03, 4.3e-04], 0.0e+00)
 Spectrum{Vector{Float64}, Float64}([1.5e-01, 2.0e-03, 6.9e-04, 3.1e-04], 0.0e+00)
 Spectrum{Vector{Float64}, Float64}([1.5e-01, 1.8e-03, 9.6e-04, 3.5e-04, 5.3e-07], 0.0e+00)
 Spectrum{Vector{Float64}, Float64}([1.5e-01, 2.0e-03, 6.9e-04, 3.1e-04], 0.0e+00)
 Spectrum{Vector{Float64}, Float64}([1.4e-01, 2.0e-03, 4.3e-04], 0.0e+00)
 Spectrum{Vector{Float64}, Float64}([1.3e-01, 1.2e-03], 0.0e+00)
 Spectrum{Vector{Float64}, Float64}([9.4e-02], 0.0e+00)

julia> is_regular_form(H,lower) == true
true

julia> isortho(H, left) == true
true

julia> check_ortho(H, left) == true
true
```


## Generating this README



This file was generated with [weave.jl](https://github.com/JunoLab/Weave.jl) with the following commands:

```julia
using ITensorMPOCompression, Weave
weave(
  joinpath(pkgdir(ITensorMPOCompression), "examples", "README.jl");
  doctype="github",
  out_path=pkgdir(ITensorMPOCompression),
)
```
